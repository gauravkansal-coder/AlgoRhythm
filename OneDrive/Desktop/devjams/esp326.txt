#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include <BLE2902.h>
#include "mbedtls/sha256.h" // For SHA-256 Hashing

// --- Configuration ---
#define DEVICE_NAME "cheesekeeper"
#define LED_PIN 2
#define SCRAMBLE_KEY 0xAB // For password auth obfuscation ONLY

// BLE Service and Characteristic UUIDs
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CMD_CHAR_UUID       "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define RSP_CHAR_UUID       "beb5483f-36e1-4688-b7f5-ea07361b26a8"
#define MAX_PAYLOAD_LENGTH  512 // Increased for AES ciphertext

// --- Global Objects ---
Preferences prefs;
BLECharacteristic *pResponseCharacteristic;
bool deviceConnected = false;
bool isAuthenticated = false;

// --- Utility Functions ---
void setLed(bool on) {
    digitalWrite(LED_PIN, on ? HIGH : LOW);
}

void scramble(char *data) {
    for (int i = 0; data[i] != '\0'; i++) {
        data[i] = data[i] ^ SCRAMBLE_KEY;
    }
}

// NEW: Function to calculate SHA-256 hash
String calculateSHA256(const char* data) {
    byte hash[32];
    mbedtls_sha256_context ctx;
    mbedtls_sha256_init(&ctx);
    mbedtls_sha256_starts(&ctx, 0); // 0 for SHA-256
    mbedtls_sha256_update(&ctx, (const unsigned char*)data, strlen(data));
    mbedtls_sha256_finish(&ctx, hash);
    mbedtls_sha256_free(&ctx);

    char hash_str[65];
    for (int i = 0; i < 32; i++) {
        sprintf(hash_str + i * 2, "%02x", hash[i]);
    }
    hash_str[64] = 0;
    return String(hash_str);
}


void sendResponse(const char* status, const char* data) {
    if (deviceConnected && pResponseCharacteristic) {
        JsonDocument doc;
        doc["status"] = status;
        doc["data"] = data;

        String output;
        serializeJson(doc, output);
        pResponseCharacteristic->setValue((uint8_t*)output.c_str(), output.length());
        pResponseCharacteristic->notify();
    }
}

// --- Command Handler ---
void handleCommand(const std::string &value) {
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, value);

    if (error) {
        sendResponse("0", "Invalid JSON");
        return;
    }

    const char* command = doc["command"];
    
    if (strcmp(command, "login") == 0) {
        char payload[128];
        strlcpy(payload, doc["payload"], sizeof(payload));
        scramble(payload); // Unscramble received password

        String receivedHash = calculateSHA256(payload);
        String storedHash = prefs.getString("authPassHash", "");
        
        if (storedHash.length() > 0 && receivedHash == storedHash) {
            isAuthenticated = true;
            setLed(true);
            String encryptedFragment = prefs.getString("aesFragment", "");
            sendResponse("2", encryptedFragment.c_str());
        } else {
            sendResponse("0", "Login Failed");
        }
    } 
    else if (strcmp(command, "setPassword") == 0) {
        char payload[128];
        strlcpy(payload, doc["payload"], sizeof(payload));
        scramble(payload); // Unscramble new password
        
        String passwordHash = calculateSHA256(payload);
        prefs.putString("authPassHash", passwordHash);
        
        isAuthenticated = true;
        setLed(true);
        sendResponse("1", "Password Set Successfully");
    }
    else if (strcmp(command, "storeFragment") == 0) {
        if (!isAuthenticated) {
            sendResponse("0", "Not Authenticated");
            return;
        }
        const char* payload = doc["payload"];
        if (strlen(payload) > MAX_PAYLOAD_LENGTH - 1) {
             sendResponse("0", "Error: Payload too large.");
             return;
        }
        prefs.putString("aesFragment", payload);
        sendResponse("0", "Encrypted fragment stored.");
    } 
    else if (strcmp(command, "logout") == 0) {
        isAuthenticated = false;
        setLed(false); // Turn off LED to indicate logged out but connected
        sendResponse("3", "Logout Successful");
    }
}


// --- BLE Callbacks ---
class ServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        deviceConnected = true;
    }
    void onDisconnect(BLEServer* pServer) {
        deviceConnected = false;
        isAuthenticated = false;
        setLed(false);
        BLEDevice::startAdvertising(); // Restart advertising
    }
};

class CommandCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
        String value = pCharacteristic->getValue();
        if (value.length() > 0) {
            handleCommand(value.c_str());
        }
    }
};

// --- Main Setup & Loop ---
void setup() {
    WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); // Disable brownout detector
    setCpuFrequencyMhz(80);

    pinMode(LED_PIN, OUTPUT);
    setLed(false);

    prefs.begin("cheesekeeper", false);

    BLEDevice::init(DEVICE_NAME);
    BLEServer *pServer = BLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    
    BLEService *pService = pServer->createService(SERVICE_UUID);

    pResponseCharacteristic = pService->createCharacteristic(
        RSP_CHAR_UUID,
        BLECharacteristic::PROPERTY_NOTIFY
    );
    pResponseCharacteristic->addDescriptor(new BLE2902());

    BLECharacteristic *pCommandCharacteristic = pService->createCharacteristic(
        CMD_CHAR_UUID,
        BLECharacteristic::PROPERTY_WRITE
    );
    pCommandCharacteristic->setCallbacks(new CommandCallbacks());

    pService->start();

    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    BLEDevice::startAdvertising();
}

void loop() {
    // Logic is event-driven by BLE callbacks, but we can manage LED here
    static unsigned long lastBlinkTime = 0;
    if (deviceConnected && !isAuthenticated) {
        if (millis() - lastBlinkTime > 1000) {
            digitalWrite(LED_PIN, !digitalRead(LED_PIN)); // Slow blink
            lastBlinkTime = millis();
        }
    } else if (!deviceConnected) {
        setLed(false); // Off when disconnected
    } else if (isAuthenticated) {
        setLed(true); // Solid on when authenticated
    }
    delay(100); // Small delay to prevent busy-looping
}

